#!/usr/bin/tclsh
# vim:set syntax=tcl:
# vim:set nowrap:

#
# TODO
#
# - MDTM: modification date and time.
# - Binary and contiguous files?
# - Don't "die" on the client. 
# - Don't leave the dimmer on.
# - Return errors to the client.
# - Check password by doing an MTM login, also pick up HOME dir.
#

package require Expect
package require ftpd

namespace eval OS32 {

   variable ftpcmd  ""
   variable ftpsok  ""
 
   #
   # Disable the bits we don't want, or haven't gotten round to.
   #

   rename ::ftpd::Fs {}

   proc ::ftpd::command::MKD { sock prm } {
      ::OS32::NoTransmit $sock "500 Make directory not supported on OS/32"
   }

   proc ::ftpd::command::XMKD { sock prm } {
      ::OS32::NoTransmit $sock "500 Make directory not supported on OS/32"
   }

   proc ::ftpd::command::RMD { sock prm } {
      ::OS32::NoTransmit $sock "500 Remove directory not supported on OS/32"
   }

   proc ::ftpd::command::XRMD { sock prm } {
      ::OS32::NoTransmit $sock "500 Remove directory not supported on OS/32"
   }

   proc ::ftpd::command::SIZE { sock prm } {
      ::OS32::NoTransmit $sock "500 File size not supported (record oriented filesystem)"
   }

   proc ::ftpd::command::APPE {sock prm} { ::OS32::NoTransmit $sock "500 TODO: APPE" ; puts "\n\n*** TODO: APPE (APPEND) ****" }
   proc ::ftpd::command::MDTM {sock prm} { ::OS32::NoTransmit $sock "500 TODO: MDTM" ; puts "\n\n*** TODO: MDTM (MODIFIED DATE TIME) ****" }
   proc ::ftpd::command::STOU {sock prm} { ::OS32::NoTransmit $sock "500 TODO: STOU" ; puts "\n\n*** TODO: STOU (STORE UNIQUE) ****" }

;#########################################################################
   #
   # CWD -- Change working directory
   #
   # Format is VOLUME:/ACCOUNT. VOLUME starts with a letter, followed by a
   # maximum of three letters or digits. ACCOUNT is an unsigned 16 bit
   # integer (i.e. less than 65636).
   #
   # If the request includes a volume name, we schedule a BottomHalf to run
   # a CHECKVOL script, with awk-like pattern matching to determine success
   # or failure. The final response is returned with the NoTransmit proc.
   #

   namespace eval CWD {

      upvar #0 [namespace parent]::ftpsok ftpsok

      proc ::ftpd::command::CWD { sock dir } {
         ::OS32::CWD::TopHalf $sock $dir
      }

      proc TopHalf { sock dir } {

         upvar #0 ::ftpd::$sock data

         # Obvious errors
         set dir [string toupper $dir]
         if { ![regexp {^([A-Z][A-Z0-9]{0,3}:?)?/?([0-9]+)?$} $dir -> vol act] } {
            puts $sock "550 Not a directory (must be NUMBER, VOLUME, or VOLUME:/NUMBER)"
            return
         }
         if { $act != "" } {
            if { $act > 65535 } {
               puts $sock "550 Not a directory, account must be less than 65536"
               return
            }
         }

         # Immediate success
         if { $vol == "" } {
            set data(cwd) $act
            puts $sock "250 Directory is now $data(vol)/$data(cwd)"
            return
         }

         # Or bottom half if we have to check the volume exists
         ::OS32::CheckOperatorBusy $sock
         set data(rvol) $vol
         if { $act != "" } { set data(ract) $act }
         ::OS32::BottomHalf $sock CWD "FTP CHECKVOL,[lindex [split $vol :] 0]"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpsok
               variable dimmeris
               upvar #0 ::ftpd::$ftpsok data
            }
            "^\\*=== BEGIN CHECKVOL (.*) ===" {
               dimmer on $0
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  NoTransmit $ftpsok "404 Command line error, try again"
               } else {
                  set data(error) "550 $1"
               }
            }
            "^\\*VOLUME (.*) OK" {
            }
            "^\\*VOLUME (.*) NOT FOUND" {
               set data(error) "550 No such volume, $1, or disk not marked on"
            }
            "^\\*=== END CHECKVOL (.*) ===" {
               dimmer off $0
               if { [info exists data(error)] } {
                  if { [info exists data(ract)] } {
                     unset data(ract)
                  }
                  NoTransmit $ftpsok $data(error)
                  unset data(rvol)
                  unset data(error)
               } else {
                  if { [info exists data(ract)] } {
                     set data(cwd) $data(ract)
                     unset data(ract)
                  }
                  set data(vol) $data(rvol)
                  if { ![string match *: $data(vol)] } { append data(vol) : }
                  unset data(rvol)
                  NoTransmit $ftpsok "250 Directory is now $data(vol)/$data(cwd)"
               }
            }
         }
      }
   }

;#########################################################################
   #
   # CDUP -- Go up one directory level
   #
   # OS/32 directories cannot be nested, so we'll simply return to the initial
   # or default directory.
   #

   namespace eval CDUP {
      proc ::ftpd::command::CDUP { sock list } {
         ::ftpd::command::CWD $sock 0 ;# TODO should pick this up from MTM
      }
   }

;#########################################################################
   #
   # DELE -- Delete file
   #
   # Delete a file, again through a CSS wrapper.
   #

   namespace eval DELE {

      # Bring parent variables into scope
      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::ftpsok ftpsok

      proc ::ftpd::command::DELE { sock fnam } {
         ::OS32::DELE::TopHalf $sock $fnam DELE
      }

      proc TopHalf { sock fnam ftpcmd } {
         ::OS32::CheckOperatorBusy $sock
         set fnam [::OS32::WildFile $sock [string toupper $fnam] $ftpcmd]
         upvar #0 ::ftpd::$sock data
         set data(fnam) $fnam
         ::OS32::BottomHalf $sock $ftpcmd "FTP DELETE,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable ftpsok
               variable dimmeris
               upvar #0 ::ftpd::$ftpsok data
            }
            "^\\*=== BEGIN DELETE (.*) ===" {
               dimmer on $0
            }
            "^\\*(DELE-ERR  TYPE=PROT)" {
               set data(error) "550 Delete error, file is protected"
            }
            "^\\*(DELE-ERR  TYPE=NAME)" {
               set data(error) "550 File not found, $data(fnam)"
            }
            "^\\*(DELE-ERR.*)" {
               set data(error) "550 Delete error: $1"
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  NoTransmit $ftpsok "404 Command line error, try again"
               } else {
                  set data(error) "550 $1"
               }
            }
            "^\\*=== END DELETE (.*) ===" {
               dimmer off  $0
               if { [info exists data(error)] } {
                  NoTransmit $ftpsok $data(error)
                  unset data(error)
               } else {
                  NoTransmit $ftpsok "250 Delete $data(fnam) successful"
               }
               unset data(fnam)
            }
         }
      }
   }

;#########################################################################
   #
   # LIST -- List files
   #
   # Invoke DISPLAY FILES through a CSS wrapper. We allow UNIX and OS/32 
   # wildcards. Asterisks are converted to dashes, question marks to asterisks.
   #
   # This command uses the passive mode socket, with BeginTransmit and 
   # EndTransmit, or NoTransmit on error.
   #

   namespace eval LIST {

      # Bring parent variables into scope
      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::ftpsok ftpsok

      proc ::ftpd::command::LIST { sock fnam } {
         ::OS32::LIST::TopHalf $sock $fnam LIST
      }

      proc TopHalf { sock fnam ftpcmd } {
         ::OS32::CheckOperatorBusy $sock
         set fnam [::OS32::WildFile $sock [string toupper $fnam] $ftpcmd]
         upvar #0 ::ftpd::$sock data
         set data(fnam) $fnam
         ::OS32::BottomHalf $sock $ftpcmd "FTP DIR,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable ftpsok
               variable dimmeris
               upvar #0 ::ftpd::$ftpsok data
            }
            "^\\*=== BEGIN DIR .*? ===" {
               dimmer on $0
            }
            "^\\*FILE.S. NOT FOUND ON .*" {
               set data(error) "550 File(s) not found, $data(fnam)"
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  NoTransmit $ftpsok "404 Command line error, try again"
               } else {
                  set data(error) "550 $1"
               }
            }
            "^\\*(VOLUME= .*)" {
               BeginTransmit $ftpsok "DIR $data(fnam)"
               if { $ftpcmd == "LIST" } {
                  puts -nonewline $data(sock2) "$1\r\n"
               }
            }
            "^\\* (........).(...)/(.....) (.. .+)" {
               if { $ftpcmd == "LIST" } {
                  puts -nonewline $data(sock2) " $1.$2/$3 $4\r\n"
               }
               if { $ftpcmd == "NLST" } {
                  set nam [string trim $1]
                  set ext [string trim $2]
                  puts -nonewline $data(sock2) [string tolower "$nam.$ext\r\n"]
               }
            }
            "^\\*=== END DIR .*? ===" {
               dimmer off $0
               if { [info exists data(error)] } {
                  NoTransmit $ftpsok $data(error)
                  unset data(error)
               } else {
                  EndTransmit $ftpsok "DIR $data(fnam)"
               }
               unset data(fnam)
            }
         }
      }
   }

;#########################################################################
   #
   # NLST -- List file names
   #
   # This is a variation of the LIST command that only returns file names.
   # It is is typically invoked by the FTP client's mget command to resolve
   # remote wildcards.
   #

   namespace eval NLST {

      proc ::ftpd::command::NLST { sock fnam } {
         ::OS32::LIST::TopHalf $sock $fnam NLST
      }

      proc LinePatternMatch { line } {
         ::OS32::LIST::LinePatternMatch $line
      }
   }

;#########################################################################
   #
   # PASS -- Check password
   #
   # Use the username/passwords array from the ftpd.config file. We really
   # ought to try doing an MTM login so we don't have to store our passwords
   # in cleartext.
   #

   namespace eval PASS {

      #
      # Note override. ftpd will call us, and we'll call back into ftpd
      # by doing a base call.
      #

      rename ::ftpd::command::PASS ::ftpd::command::_PASS

      proc ::ftpd::command::PASS { sock password } {
         ::OS32::CheckOperatorBusy $sock
         upvar #0 ::ftpd::$sock data
         set data(cwd) 0
         set data(vol) "SYS:"
         ::ftpd::command::_PASS $sock $password
      }

      # This proc is passed as an option to the ::ftpd::server command.
      proc AuthUserCallback { user pass } {
         upvar #0 ::[namespace parent]::config::passwords passwords
         if { [array names passwords -exact $user] == $user &&
              [set passwords($user)] == $pass } {
            ::OS32::trafficlight green "FTP USER $user LOGGED IN"
            return 1
         } else {
            ::OS32::trafficlight red "FTP USER $user FAILED LOGIN"
            return 0
         }
      }
   }

;#########################################################################
   #
   # PWD -- Print working directory
   #
   # Returns the current "working directory", i.e. volume and account, to
   # the client. We're overriding the built-in version because we're not
   # doing it UNIX style.
   #

   namespace eval PWD {
      proc ::ftpd::command::PWD { sock argument } {
         upvar #0 ::ftpd::$sock data
         puts $sock "250 Current directory is $data(vol)/$data(cwd)"
      }
   }

;#########################################################################
   #
   # RETR -- Retrieve file
   #
   # TYPE the file, and capture the meanful bits. Because OS/32 has no 
   # built-in TYPE command, we are using a CSS to run COPY32 and copy the 
   # file to the console. It also wraps the output in ===BEGIN===/===END===
   # markers.
   #

   namespace eval RETR {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::ftpsok ftpsok

      proc ::ftpd::command::RETR { sock fnam } {
         ::OS32::RETR::TopHalf $sock $fnam
      }

      proc TopHalf { sock fnam } {
         ::OS32::CheckOperatorBusy $sock
         set fnam [::OS32::WildFile $sock [string toupper $fnam] RETR]
         upvar #0 ::ftpd::$sock data
         set data(fnam) $fnam
         ::OS32::BottomHalf $sock RETR "FTP COPYOUT,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable ftpsok
               variable dimmeris
               upvar #0 ::ftpd::$ftpsok data
            }
            "^\\*=== BEGIN COPYOUT .*? ===" {
               dimmer on $0
               BeginTransmit $ftpsok $data(fnam)
            }
            "^\\*FILE NOT FOUND" {
               set data(error) "550 File not found, $data(fnam)"
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  NoTransmit $ftpsok "404 Command line error, try again"
               } else {
                  set data(error) "550 $1"
               }
            }
            "^\\*.*\\.BG:(PERKIN-ELMER OS/32 COPY)" {
               # ignore
            }
            "^\\*.*\\.BG:END OF TASK" {
               # ignore
            }
            "^\\*.*\\.BG:(.*)" {
               puts -nonewline $data(sock2) "$1\r\n"
            }
            "^\\*=== END COPYOUT .*? ===" {
               dimmer off $0
               if { [info exists data(error)] } {
                  NoTransmit $ftpsok $data(error)
                  unset data(error)
               } else {
                  EndTransmit $ftpsok $data(fnam)
               }
            }
         }
      }
   }

;#########################################################################
   #
   # RNFR/RNTO -- Rename file
   #

   namespace eval RNFR {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::ftpsok ftpsok
      upvar #0 [namespace parent]::osline osline

      proc ::ftpd::command::RNFR { sock fnam } {
         ::OS32::RNFR::TopHalf $sock $fnam
      }

      proc TopHalf { sock fnam } {

         upvar #0 ::ftpd::$sock data

         set fnam [::OS32::WildFile $sock [string toupper $fnam] RNFR]
         set data(fnam1) $fnam

         puts $sock "350 RNFR OK"
      }
   }

   namespace eval RNTO {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::ftpsok ftpsok
      upvar #0 [namespace parent]::osline osline

      proc ::ftpd::command::RNTO { sock fnam } {
         ::OS32::RNTO::TopHalf $sock $fnam
      }

      proc TopHalf { sock fnam } {
         ::OS32::CheckOperatorBusy $sock
         upvar #0 ::ftpd::$sock data
         set fnam [::OS32::WildFile $sock [string toupper $fnam] RNTO]
         set data(fnam2) $fnam
         ::OS32::BottomHalf $sock RNTO "FTP RENAME,$data(fnam1),$data(fnam2)"
      }

      proc LinePatternMatch { line } {

         awkward $line {
            BEGIN {
               variable ftpcmd
               variable ftpsok
               variable dimmeris
               upvar #0 ::ftpd::$ftpsok data
            }
            "^\\*=== BEGIN RENAME (.*) (.*) ===" {
               dimmer on $0
            }
            "^\\*(ASGN-ERR  TYPE=NAME.*)" {
               set data(error) "550 File not found, $data(fnam1)"
            }
            "^\\*(RENM-ERR  TYPE=NAME.*)" {
               set data(error) "550 Destination $data(fnam2) already exists, $data(fnam1) not renamed"
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  NoTransmit $ftpsok "404 Command line error, try again"
               } else {
                  set data(error) "550 $1"
               }
            }
            "^\\*(FILE RENAMED)" {
               # ignore
            }
            "^\\*=== END RENAME (.*) (.*) ===" {
               dimmer off $0
               if { [info exists data(error)] } {
                  NoTransmit $ftpsok $data(error)
                  unset data(error)
               } else {
                  NoTransmit $ftpsok "250 $data(fnam1) renamed $data(fnam2)"
               }
               unset data(fnam1)
               unset data(fnam2)
            }
         }
      }
   }


;#########################################################################
   #
   # STOR -- Store file
   #
   # Invoke EDIT/32 through a CSS that allocates and renames the temporary
   # files, and cleans up after itself. This one is complicated by the fact
   # that we do not know the record length in the top half, and we cannot
   # receive data while in that socket event.
   #
   # This is where we introduce a proc called PromptPatternMatch, which
   # checks for prompts, before we get the carriage return that would
   # trigger LinePatternMatch.
   #

   namespace eval STOR {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::ftpsok ftpsok
      upvar #0 [namespace parent]::osline osline

      proc ::ftpd::command::STOR { sock fnam } {
         ::OS32::STOR::TopHalf $sock $fnam
      }

      proc TopHalf { sock fnam } {
         ::OS32::CheckOperatorBusy $sock
         upvar #0 ::ftpd::$sock data
         set fnam [::OS32::WildFile $sock [string toupper $fnam] STOR]
         set data(fnam) $fnam
         # This command will fail with a USAGE error
         ::OS32::BottomHalf $sock STOR "FTP STOR,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable ftpsok
               variable dimmeris
               upvar #0 ::ftpd::$ftpsok data
            }
            # Now we can read all the data to work out the record length
            "^\\*STOR GO AHEAD" {
               dimmer on $0
               BeginTransmit $ftpsok $data(fnam)
               set data(reclen) 80
               set data(nrec) 0
               set data(ccc) 0
               while { [gets $data(sock2) line] > 0 } {
                  set line [string trimright $line]
                  lappend data(storme) $line
                  set len [string length $line]
                  if { $len > $data(reclen) } { set data(reclen) $len }
                  incr data(nrec)
               }
               if { [expr $data(reclen)%4] > 0 } {
                  incr data(reclen) [expr 4-$data(reclen)%4]
               }
               # This command should work now
               send -- "FTP COPYIN,$data(fnam),$data(reclen)\r"
            }
            "^\\*=== BEGIN COPYIN .*? ===" {
            }
            "^\\*(DELE-ERR  TYPE=PROT)" {
               set data(error) "550 Cannot upload file because it is write protected"
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  NoTransmit $ftpsok "404 Command line error, try again"
               } else {
                  set data(error) "550 $1"
               }
            }
            "^\\*=== END COPYIN .*? ===" {
               dimmer off $0
               if { [info exists data(error)] } {
                  NoTransmit $ftpsok $data(error)
                  unset data(error)
               } else {
                  EndTransmit $ftpsok "$data(fnam), $data(nrec) records, $data(reclen) chars reclen"
               }
               unset data(reclen)
               unset data(nrec)
               unset data(ccc)
            }
         }
      }

      proc PromptPatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpsok
               variable osline
               upvar #0 ::ftpd::$ftpsok data
            }
            "^\\*.+\\.BG:.+\\.BG>" {
               if { $data(ccc) < $data(nrec) } {
                  set line [lindex $data(storme) $data(ccc)]
                  if { $line == "" } { set line " " }
                  send -- "$line\r"
                  incr data(ccc)
               } else {
                  unset data(storme)
                  send -- "\r"
               }
               set osline ""
            }
            "^\\*\\.BG>" {
               send -- "done\r"
               set osline ""
            }
         }
      }
   }

;#########################################################################
   #
   # SYST -- Return system information
   #
   # No use pretending that we are UNIX or Windows. You can configure the
   # ostype in ftpd.config.
   #

   namespace eval SYST {
      proc ::ftpd::command::SYST { sock list } {
         upvar #0 ::OS32::config::ostype ostype
         puts $sock "215 $ostype"
      }
   }

;#########################################################################
   #
   # USER -- User connect
   #
   # Slightly misleading. We're checking the client IP address. We can't
   # check the username until we receive the PASS command.
   #

   namespace eval USER {

      proc AuthIpCallback { ip } {
         upvar #0 ::OS32::config::allowip allowip
         if { $allowip != "all" } {
            foreach allow $allowip {
               if { $ip == $allow } {
                  # success/fail will get logged by PASS command
                  return 1
               }
            }
            # Outsiders!
            ::OS32::trafficlight red "FTP CONNECTION ($ip) REJECTED"
            return 0
         } else {
            # free for all!
            ::OS32::trafficlight green "FTP CONNECTION ($ip) ACCEPTED"
            return 1
         }
      }
   }

;#########################################################################
   #
   # Bottom half and convenience routines.
   #

   proc WildFile { sock fnam cmd } {

      set fnam [string toupper $fnam]

      if { $cmd == "LIST" || $cmd == "NLST" } {
         set re {^([-*A-Z][-*A-Z0-9]*)(\.[-*A-Z0-9]*)?$}
         set fnam [string map { * - ? * } $fnam]
         set acceptnull 1
         set err "501 Invalid filename or wildcard pattern"
      } else {
         set re {^([A-Z][A-Z0-9]*)(\.[A-Z0-9]*)?$}
         set acceptnull 0
         set err "501 Invalid filename $fnam, must be letters, digits, 8.3 max"
      }

      if { $fnam == "" } {
         if { $acceptnull == 0 } {
            puts $sock "501 Missing filename"
            return -level 2
         }
      } elseif { ![regexp $re $fnam -> nam ext] } {
         puts $sock $err
         return -level 2                  ;# extension inc dot -----v
      } elseif { [string length $nam] > 8 || [string length $ext] > 4 } {
         puts $sock "501 Invalid filename $fnam, 8.3 max"
         return -level 2
      }

      upvar #0 ::ftpd::$sock data
      return $data(vol)$fnam/$data(cwd)
   }

   proc CheckOperatorBusy {sock} {
      variable taskcount
      if { $taskcount > 0 } {
         puts $sock "404 Operator busy, do not disturb"
         return -level 2
      }
   }

   proc BottomHalf { sock ftpcm oscmd } {
      variable ftpcmd $ftpcm
      variable ftpsok $sock
      send -- "$oscmd\r"
   }

   proc BeginTransmit { sock ftpcmd } {
      puts $sock "150 Begin $ftpcmd"
      ::ftpd::PasvCheckAndWait $sock
   }

   proc EndTransmit { sock ftpcmd } {
      NoTransmit $sock "226 End $ftpcmd"
   }

   proc NoTransmit { sock mess } {
      ::ftpd::FinishData $sock
      puts $sock $mess
      variable ftpcmd ""
      variable ftpsok ""
   }

   proc LogNothing { severity wot } {
      return
   }

   variable dimmeris off
   variable vt100

   array set vt100 {
      red    "\x1b\[31;1m"
      green  "\x1b\[32m"
      grey   "\x1b\[2m"
      normal "\x1b\[0m"
      on     "\x1b\[2m"
      off    "\x1b\[0m"
   }

   proc dimmer { onoff { str "" } } {
      variable vt100
      switch $onoff {
         "on" {
            puts -nonewline "\r$vt100(on)$str"
            variable dimmeris on
         }
         "off" {
            puts -nonewline "\r$str$vt100(off)"
            variable dimmeris off
         }
      }
   }

   proc trafficlight { colour message } {
      variable dimmeris
      variable vt100
      set cn [set vt100($colour)]
      set dm [set vt100($dimmeris)]
      puts -nonewline "\r*$cn$message$dm\n*"
   }

;#########################################################################
   #
   # Our awk-like pattern matching construct
   #

   proc awkward { 0 arglist } {
      set awk {}
      foreach line [split $arglist \n] {
         set line [string trim $line]
         if { $line == "" || [string range $line 0 0] == "#" } continue
         if { $awk != "" } { append awk \n }
         append awk $line
      }
      set match 0
      foreach { re action } $awk {
         if { $re == "BEGIN" || $re == "END" } {
            eval $action
            continue
         }
         if { !$match && [regexp $re $0 -> 1 2 3 4 5 6 7 8 9] } {
            eval $action
            set match 1
            continue
         }
      }
      return $match
   }

   # reference 'awkward' in the global namespace for convenience
   proc ::awkward { 0 awk } {
      return [::OS32::awkward $0 $awk]
   }

;#########################################################################
   #
   # FTP start, stop, users
   #

   proc CheckWeHaveFTP {} {
      if { ![info exists config::host] ||
           ![info exists config::port] ||
           $config::port <= 0 } {
         puts -nonewline "\nFTP server is disabled"
         return -level 2
      }
   }

   proc StartFTP {} {

      CheckWeHaveFTP

      upvar #0 ::ftpd::serviceSock serviceSock

      if { [info exists serviceSock] } {
         puts -nonewline "\nFTP server already running"
         return
      }

      set ::ftpd::welcome $config::welcome
      set ::ftpd::contact $config::contact
      set ::ftpd::port    $config::port

      ftpd::config -authIpCmd ::OS32::USER::AuthIpCallback
      ftpd::config -logCmd    ::OS32::LogNothing

      if [info exists config::passwords] {
         ftpd::config -authUsrCmd ::OS32::PASS::AuthUserCallback
      }

      ftpd::server $config::host

      variable vt100
      puts -nonewline "\n$vt100(green)$config::welcome $config::host port $config::port$vt100(normal)"
   }

   proc StopFTP {} {

      CheckWeHaveFTP

      upvar #0 ::ftpd::serviceSock serviceSock

      if { ![info exists serviceSock] } {
         puts -nonewline "\nFTP server not running"
         return
      }

      puts ""
      set socks [info vars ::ftpd::sock*]
      if { [llength $socks] > 0 } {
         foreach sock $socks {
            puts "Closing client socket $sock"
            regsub ::ftpd:: $sock {} sock
            chan close $sock
            array unset ::ftpd::$sock
         }
      }
      puts -nonewline "Closing listening socket"
      chan close $serviceSock
      unset serviceSock
   }

   proc ShowFTP {} {

      CheckWeHaveFTP

      upvar #0 ::ftpd::serviceSock serviceSock

      if { ![info exists serviceSock] } {
         puts -nonewline "\nFTP server not running"
         return
      }

      set n 0
      puts ""
      foreach sock [info vars ::ftpd::sock*] {
         upvar $sock data
         puts "$data(user)@$data(ip)"
         incr n
      }
      puts -nonewline "$n CONNECTED"
   }

;#########################################################################
   #
   # The interact/expect loop
   #

   variable osline ""
   variable taskcount 0

   proc DoExpect {} {
      namespace eval :: {
         interact {
            -o
            # We'll usually trigger pattern matching on <CR>.
            -re "\r" {
               upvar #0 ::OS32::osline osline
               if { [string match "TSKID = *" $osline] } {
                  incr ::OS32::taskcount
               } elseif { [string match "*:END OF TASK*" $osline] } {
                  incr ::OS32::taskcount -1
               }
               upvar #0 ::OS32::ftpcmd ftpcmd
               if { $ftpcmd != "" } {
                  set LinePatternMatch ::OS32::[set ftpcmd]::LinePatternMatch
                  if { [info procs $LinePatternMatch] != "" } {
                     $LinePatternMatch $osline
                  }
               } elseif { $osline == "*START FTP SERVER" } {
                  ::OS32::StartFTP
               } elseif { $osline == "*STOP FTP SERVER" } {
                  ::OS32::StopFTP
               } elseif { $osline == "*SHOW FTP USERS" } {
                  ::OS32::ShowFTP
               }
               puts ""
               set osline ""
            }
            # Discard <NL> and annoying <DEL> characters.
            -re "(\n|\x7f)" {
            }
            # All other characters are echoed and assembled into lines. But
            # some OS/32 programs have their own prompts that have to spot
            # before we ever get a carriage return.
            -re . {
               upvar #0 ::OS32::ftpcmd ftpcmd
               upvar #0 ::OS32::osline osline
               set c $interact_out(0,string)
               if { $c != 0x7f } {
                  append osline $c
                  puts -nonewline stderr $c
               }
               if { $ftpcmd != "" } {
                  set PromptPatternMatch ::OS32::[set ftpcmd]::PromptPatternMatch
                  if { [info procs $PromptPatternMatch] != "" } {
                     $PromptPatternMatch $osline
                  }
               }
            }
         }
      }
   }

;#########################################################################
   #
   # Main program
   #

   dimmer off

   if { [file exists ftpd.config] } {
      source ftpd.config
      StartFTP
      puts ""
   }

   namespace eval :: {
      catch { exec killall -9 id32 } 
      spawn ./id32 os32.ini
   }
   DoExpect

   dimmer off
}
