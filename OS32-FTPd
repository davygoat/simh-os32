#!/bin/sh
## vim:set nowrap:\
## vim:set syntax=tcl:\
## FreeBSD, no symlink... ##############################################\
   TCL=$(ls {/usr,/usr/local,/opt}/bin/expect* 2>/dev/null | head -1)  #\
   [ -n "$TCL" ] || exec echo "Cannot find tclsh"                      #\
   exec $TCL "$0" ${1+"$@"}                                            #\
########################################################################
#
# TODO
#
# - ABOR for Ctrl/C.
# - Binary and contiguous files?
# - Don't "die" on the client.
# - Don't leave the dimmer on.
# - Return errors to the client.
#
# Known problems:
#
# - Some ?large FTP get requests stuck midway, esp. with mget.
#

package require Expect
package require ftpd
package require md5

namespace eval OS32 {

   namespace export CheckReadOnly
   namespace export CheckNotAllowed
   namespace export CheckOperatorBusy
   namespace export BottomHalf
   namespace export BeginData
   namespace export SendData
   namespace export EndData
   namespace export ReplyCommand
   namespace export CurrentWorkingDirectory
   namespace export InitialAccount
   namespace export CdBlacklist
   namespace export WildFile
   namespace export ShowACL
   namespace export HaveACE
   namespace export TrafficLight
   namespace export Dimmer
   namespace export awkward

   variable ftpcmd  ""
   variable sock  ""

   namespace eval config {
      array set vt100       { red    ""
                              green  ""
                              on     "\x1b\[2m"
                              off    "\x1b\[0m"
                              normal "\x1b\[0m" }
      variable  host          "localhost"
      variable  port          2121
      variable  numericlogins 1
      array set access        {}
      array set passwords     {}
      variable  allowip       127.0.0.1
      variable  cdblacklist   255
      variable  welcome       "OS/32 FTP server"
      variable  ostype        "OS/32 Version 8.1"
      variable  contact       "nobody@nowhere.not"
      variable  inifile       "os32.ini"
      variable  debugconfig   1
      variable  timeout       10
   }

;######################################################################
   #
   # Unsupported commands
   #

   rename ::ftpd::Fs {}

   proc ::ftpd::command::MKD { sock prm } {
      set ftpcmd MKD
      CheckNotAllowed $sock $ftpcmd
      CheckReadOnly $sock $ftpcmd
      ReplyCommand $sock 500 "Make directory not supported by OS/32"
   }

   proc ::ftpd::command::XMKD { sock prm } {
      set ftpcmd XMKD
      CheckNotAllowed $sock $ftpcmd
      CheckReadOnly $sock $ftpcmd
      ReplyCommand $sock 500 "Make directory not supported by OS/32"
   }

   proc ::ftpd::command::RMD { sock prm } {
      set ftpcmd RMD
      CheckNotAllowed $sock $ftpcmd
      CheckReadOnly $sock $ftpcmd
      ReplyCommand $sock 500 "Remove directory not supported by OS/32"
   }

   proc ::ftpd::command::XRMD { sock prm } {
      set ftpcmd XRMD
      CheckNotAllowed $sock $ftpcmd
      CheckReadOnly $sock $ftpcmd
      ReplyCommand $sock 500 "Remove directory not supported by OS/32"
   }

   proc ::ftpd::command::SIZE { sock prm } {
      set ftpcmd SIZE
      CheckNotAllowed $sock $ftpcmd
      ReplyCommand $sock 500 "File size not supported (record oriented filesystem)"
   }

;######################################################################
   #
   # Possible TODOs, but rarely used.
   #

   proc ::ftpd::command::MDTM {sock prm} {
      set ftpcmd MDTM
      CheckNotAllowed $sock $ftpcmd
      ReplyCommand $sock 500 "Rarely used"
   }

   proc ::ftpd::command::APPE {sock prm} {
      set ftpcmd STOU
      CheckNotAllowed $sock $ftpcmd
      CheckReadOnly $sock $ftpcmd
      ReplyCommand $sock 500 "Rarely used"
   }

   proc ::ftpd::command::STOU {sock prm} {
      set ftpcmd STOU
      CheckNotAllowed $sock $ftpcmd
      CheckReadOnly $sock $ftpcmd
      ReplyCommand $sock 500 "Rarely used"
   }

;######################################################################
   #
   # CWD -- Change working directory
   #
   # Format is VOLUME:/ACCOUNT. VOLUME starts with a letter, followed by
   # a maximum of three letters or digits. ACCOUNT is an unsigned 16 bit
   # integer (i.e. less than 65636).
   #
   # If the request includes a volume  name, we schedule a BottomHalf to
   # run a CHECKVOL script, with  awk-like pattern matching to determine
   # success  or  failure.  The  final response  is  returned  with  the
   # ReplyCommand proc.
   #

   namespace eval CWD {

      upvar #0 [namespace parent]::sock sock

      proc ::ftpd::command::CWD { sock dir } {
         ::OS32::CWD::TopHalf $sock $dir CWD
      }

      proc TopHalf { sock dir ftpcmd } {

         CheckNotAllowed $sock $ftpcmd

         upvar #0 ::ftpd::$sock data

         # Handle immediate errors
         set dir [string toupper $dir]
         if { ![regexp {^([A-Z][A-Z0-9]{0,3}:?)?/?([0-9]+)?$} $dir -> vol act] } {
            ReplyCommand $sock 550 "Not a directory (must be NUMBER, VOLUME, or VOLUME:/NUMBER)"
            return
         }
         if { $act != "" } {
            if { $act > 65535 } {
               ReplyCommand $sock 550 "Not a directory, account must be less than 65536"
               return
            }
            if { [CdBlacklist $act] } {
               ReplyCommand $sock 550 "Access denied, cd $act is not allowed"
               return
            }
            if { ![HaveACE $sock $act] && ![HaveACE $sock *] } {
               ReplyCommand $sock 550 "Access denied, your ACL is [ShowACL $sock]"
               return
            }
         }

         # Immediate success
         if { $vol == "" } {
            set data(cwd) $act
            ReplyCommand $sock 250 "Directory is now [CurrentWorkingDirectory $sock]"
            return
         }

         # Or bottom half if we have to check the volume exists
         CheckOperatorBusy $sock
         set data(rvol) $vol
         if { $act != "" } { set data(ract) $act }
         BottomHalf $sock $ftpcmd "FTP CHECKVOL,[lindex [split $vol :] 0]"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable sock
               variable dimmeris
               upvar #0 ::ftpd::$sock data
            }
            "^\\*=== BEGIN CHECKVOL (.*) ===" {
               Dimmer on $0
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  ReplyCommand $sock 450 "Command line error, try again"
               } else {
                  set data(error) [list 550 $1]
               }
            }
            "^\\*VOLUME (.*) OK" {
            }
            "^\\*VOLUME (.*) NOT FOUND" {
               set data(error) [list 550 "No such volume, $1, or disk not marked on"]
            }
            "^\\*=== END CHECKVOL (.*) ===" {
               Dimmer off $0
               if { [info exists data(error)] } {
                  if { [info exists data(ract)] } {
                     unset data(ract)
                  }
                  ReplyCommand $sock [lindex $data(error) 0] [lindex $data(error) 1]
                  unset data(rvol)
                  unset data(error)
               } else {
                  if { [info exists data(ract)] } {
                     set data(cwd) $data(ract)
                     unset data(ract)
                  }
                  set data(vol) $data(rvol)
                  if { ![string match *: $data(vol)] } { append data(vol) : }
                  unset data(rvol)
                  ReplyCommand $sock 250 "Directory is now [CurrentWorkingDirectory $sock]"
               }
            }
         }
      }
   }

;######################################################################
   #
   # CDUP -- Go up one directory level
   #
   # OS/32 directories cannot  be nested, so we'll simply  return to the
   # initial or default directory.
   #

   namespace eval CDUP {

      proc ::ftpd::command::CDUP { sock list } {
         CheckNotAllowed $sock CDUP
         ::ftpd::command::CWD $sock [InitialAccount $sock]
         # mention CheckNotAllowed to match ::ftpd::command above
      }
   }

;######################################################################
   #
   # DELE -- Delete file
   #
   # Delete a file, again through a CSS wrapper.
   #

   namespace eval DELE {

      # Bring parent variables into scope
      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::sock sock

      proc ::ftpd::command::DELE { sock fnam } {
         ::OS32::DELE::TopHalf $sock $fnam DELE
      }

      proc TopHalf { sock fnam ftpcmd } {
         CheckReadOnly $sock $ftpcmd
         CheckNotAllowed $sock $ftpcmd
         CheckOperatorBusy $sock
         set fnam [WildFile $sock [string toupper $fnam] $ftpcmd]
         upvar #0 ::ftpd::$sock data
         set data(fnam) $fnam
         BottomHalf $sock $ftpcmd "FTP DELETE,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable sock
               variable dimmeris
               upvar #0 ::ftpd::$sock data
            }
            "^\\*=== BEGIN DELETE (.*) ===" {
               Dimmer on $0
            }
            "^\\*(DELE-ERR  TYPE=PROT)" {
               set data(error) [list 550 "Delete error, file is protected"]
            }
            "^\\*(DELE-ERR  TYPE=NAME)" {
               set data(error) [list 550 "File not found, $data(fnam)"]
            }
            "^\\*(DELE-ERR.*)" {
               set data(error) [list 550 "Delete error: $1"]
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  ReplyCommand $sock 450 "Command line error, try again"
               } else {
                  set data(error) [list 550 $1]
               }
            }
            "^\\*=== END DELETE (.*) ===" {
               Dimmer off $0
               if { [info exists data(error)] } {
                  ReplyCommand $sock [lindex $data(error) 0] [lindex $data(error) 1]
                  unset data(error)
               } else {
                  ReplyCommand $sock 250 "Delete $data(fnam) successful"
               }
               unset data(fnam)
            }
         }
      }
   }

;######################################################################
   #
   # LIST -- List files
   #
   # Invoke DISPLAY FILES through a CSS wrapper. We allow UNIX and OS/32
   # wildcards.  Asterisks are  converted to  dashes, question  marks to
   # asterisks.
   #
   # This command  uses the passive  mode socket, calling  BeginData and
   # EndData to transmit the directory list, or ReplyCommand on error.
   #

   namespace eval LIST {

      # Bring parent variables into scope
      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::sock sock

      proc ::ftpd::command::LIST { sock fnam } {
         ::OS32::LIST::TopHalf $sock $fnam LIST
      }

      proc TopHalf { sock fnam ftpcmd } {
         CheckNotAllowed $sock $ftpcmd
         CheckOperatorBusy $sock
         set fnam [WildFile $sock [string toupper $fnam] $ftpcmd]
         upvar #0 ::ftpd::$sock data
         set data(fnam) $fnam
         BottomHalf $sock $ftpcmd "FTP DIR,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable sock
               variable dimmeris
               upvar #0 ::ftpd::$sock data
            }
            "^\\*=== BEGIN DIR .*? ===" {
               Dimmer on $0
            }
            "^\\*FILE.S. NOT FOUND ON .*" {
               set data(error) [list 550 "File(s) not found, $data(fnam)"]
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  ReplyCommand $sock 450 "Command line error, try again"
               } else {
                  set data(error) [list 550 $1]
               }
            }
            "^\\*(VOLUME= .*)" {
               BeginData $sock 150 "Transmitting DIR $data(fnam)"
               if { $ftpcmd == "LIST" } {
                  SendData $sock "$1"
               }
            }
            "^\\* (FILENAME...........+)" {
               if { $ftpcmd == "LIST" } {
                  SendData $sock " $1"
               }
            }
            "^\\* (........).(...)/(.....) (.. .+)" {
               if { $ftpcmd == "LIST" } {
                  SendData $sock " $1.$2/$3 $4"
               }
               if { $ftpcmd == "NLST" } {
                  set nam [string trim $1]
                  set ext [string trim $2]
                  SendData $sock [string tolower "$nam.$ext"]
               }
            }
            "^\\*=== END DIR .*? ===" {
               Dimmer off $0
               if { [info exists data(error)] } {
                  ReplyCommand $sock [lindex $data(error) 0] [lindex $data(error) 1]
                  unset data(error)
               } else {
                  EndData $sock 226 "DIR $data(fnam) received"
               }
               unset data(fnam)
            }
         }
      }
   }

;######################################################################
   #
   # NLST -- List file names
   #
   # This is  a variation  of the  LIST command  that only  returns file
   # names. It is is typically invoked  by the FTP client's mget command
   # to resolve remote wildcards.
   #

   namespace eval NLST {

      proc ::ftpd::command::NLST { sock fnam } {
         set ftpcmd NLST
         CheckNotAllowed $sock $ftpcmd
         ::OS32::LIST::TopHalf $sock $fnam $ftpcmd
      }

      proc LinePatternMatch { line } {
         ::OS32::LIST::LinePatternMatch $line
      }
   }

;######################################################################
   #
   # PASS -- Check password
   #
   # There are three options:
   #
   # - If the username is listed in the passwords array, do an MD5 check.
   # - If the username is numeric, do a straight MTM signon.
   # - If the username is not numeric, do a lookup, and then try MTM.
   #

   namespace eval PASS {

      proc ::ftpd::command::PASS { sock pass } {

         # Note: CheckNotAllowed not possible this early
         CheckOperatorBusy $sock

         upvar #0 ::ftpd::$sock data
         upvar #0 ::OS32::mtmport mtmport
         upvar #0 ::OS32::config::numericlogins numericlogins
         upvar #0 ::OS32::config::access access
         upvar #0 ::OS32::config::passwords passwords

         set user $data(user)
         set data(pass) $pass
         set data(acl) -vt

         #
         # Numeric logins  can be disabled  because they are  too easily
         # enumerated.
         #

         if { [string is integer $user] && !$numericlogins } {
            TrafficLight red "FTP USER $user FAILED LOGIN (numeric logins disabled)"
            ReplyCommand $sock 551 "Access denied"
            return
         }

         #
         # Named users  must be  listed in  the access  array so  we can
         # assign them to numeric accounts. However, we  DO NOT  want to
         # tell the client that their  username is invalid -- that's bad
         # practice these days.
         #

         if { ![info exists access($user)] && ![string is integer $user] } {
            TrafficLight red "FTP USER $user FAILED LOGIN (not in config::access)"
            ReplyCommand $sock 551 "Access denied"
            return
         }

         #
         # On the  other hand, you  may want to explicitly  disable some
         # users. In that case it makes sense to tell them off.
         #

         if { [info exists access($user)] && ![llength [set access($user)]] } {
            TrafficLight red "FTP USER $user FAILED LOGIN (empty acl)"
            ReplyCommand $sock 551 "User $user is denied ftp access"
            return
         }

         #
         # Set up defaults. Named users  start in the first account that
         # is listed in  their acl. Numeric users will  be restricted to
         # just the  account they  sign on with.  But don't  let default
         # their way around the cd blacklist.
         #

         set data(vol) "SYS:"
         set data(cwd) -1

         if { [string is integer $user] } {
            set data(acl) "$user -vt"
            set data(cwd) $user
            if { [CdBlacklist $data(cwd)] } {
               TrafficLight red "FTP USER $user FAILED LOGIN (numeric login on cd blacklist)"
               ReplyCommand $sock 551 "Access denied"
               return
            }
         } else {
            set data(acl) [set access($user)]
            set data(cwd) [InitialAccount $sock]
            if { [CdBlacklist $data(cwd)] } {
               TrafficLight red "FTP USER $user FAILED LOGIN (initial account on cd blacklist)"
               ReplyCommand $sock 551 "Access denied"
               return
            }
         }
         if { $data(cwd) < 0 } {
            TrafficLight red "FTP USER $user FAILED LOGIN (no account)"
            ReplyCommand $sock 551 "Access denied"
            return
         }

         #
         # If the  user/account is  listed in passwords,  do an  md5 and
         # check  the hash.  Note  that  we salt  with  the username  to
         # prevent hash collisions, and we also terminate with a newline
         # because the echo command pipes one in by default.
         #
         #  $ echo "myid/my password" | md5sum
         #

         if { [info exists passwords($user)] } {
            set md5 [string tolower [::md5::md5 -hex "$user/$pass\n"]]
            if { [array names passwords -exact $user] == $user &&
                 [set passwords($user)] == $md5 } {
               TrafficLight green "FTP USER $user LOGGED IN USING MD5"
               ReplyCommand $sock 230 "Password accepted, directory is [CurrentWorkingDirectory $sock]"
               set data(access) 1
               return
            } else {
               TrafficLight red "FTP USER $user FAILED LOGIN USING MD5"
               ReplyCommand $sock 551 "Access denied"
               return
            }
         }

         #
         # Otherwise we'll use MTM to authenticate. This shells out to a
         # separate expect script.
         #

         if { $mtmport > 0 } {
            if { ![string is integer $user] } {
               set acct [lindex [set access($user)] 0]
            } else {
               set acct $user
            }
            set erno [::OS32::PASS::AuthenticateMTM $acct $pass ermes]
            if { $erno == 0 } {
               TrafficLight green "FTP USER $user LOGGED IN USING MTM"
               ReplyCommand $sock 230 "MTM login successful, directory is [CurrentWorkingDirectory $sock]"
               set data(access) 1
               return
            } else {
               TrafficLight red "FTP USER $user FAILED LOGIN USING MTM ($ermes)"
               ReplyCommand $sock 551 "Access denied"
               return
            }
         }

         #
         # Now what?
         #

         ReplyCommand $sock 551 "Cannot authenticate using MTM"
         return
      }

      proc AuthenticateMTM { acct pass errvar } {

         upvar 1 $errvar ermes

         # MTM accounts must  be <= 255 by default. I'm  going to narrow
         # that a little  bit more, because 255 is  privileged, and owns
         # the MTM Authorized  User File. Account 0 is  allowed, but not
         # recommended.
         if { $acct < 0 || $acct >= 255 } {
            set ermes "out of range account"
            return -1
         }
         # According  to  the EOU  help  on  PASSWORD: "All  alphabetic,
         # numeric  and special  characters, except  blanks, commas,  or
         # semi-colons are  allowed." I'm  also going to  reject control
         # characters and nasty shell escapes.
         set badchar "\x00-\x20\x7f-\xff"
         append badchar {,;\\|$^`\[\]\{\}\"}
         if { [regexp "\[$badchar\]" $pass] } {
            set ermes "bad characters in password"
            return -1
         }

         set exp [info nameofexecutable]
         catch {
            # Yes, password could be visible to ps. That's unfortunate...
            upvar #0 ::OS32::mtmport mtmport
            set out [exec $exp mtmcheckpass.tcl $mtmport $acct $pass]]
         } err
         if { [regexp {\*\*\* FAIL ([0-9]+) \((.*?)\) \*\*\*} $err -> n reas] } {
            set ermes [string totitle $reas]
            return $n
         } elseif { ![regexp {\*\*\* SUCCESS \*\*\*} $err] } {
            puts ""
            puts "=========================================================================="
            puts " FIXME -- MTM password check returned success, but output says otherwise"
            puts -- $err
            puts "=========================================================================="
            puts ""
            return -1
         } else {
            set ermes ""
            return 0
         }
      }
   }

;######################################################################
   #
   # PWD -- Print working directory
   #
   # Returns the  current "working directory", i.e.  volume and account,
   # to the client. We're overriding  the built-in version because we're
   # not doing it UNIX style.
   #

   namespace eval PWD {
      proc ::ftpd::command::PWD { sock argument } {
         CheckNotAllowed $sock PWD
         upvar #0 ::ftpd::$sock data
         set cwd [CurrentWorkingDirectory $sock]
         ReplyCommand $sock 250 "Current directory is $cwd"
      }
   }

   proc CurrentWorkingDirectory { sock } {
      upvar #0 ::ftpd::$sock data
      set vol $data(vol)
      set cwd $data(cwd)
      set acl [ShowACL $sock]
      return "$vol/$cwd, ACL=$acl"
   }

;######################################################################
   #
   # RETR -- Retrieve file
   #
   # TYPE the file,  and capture the meanful bits. Because  OS/32 has no
   # built-in  TYPE command,  we  are  using a  CSS  to  run COPY32  and
   # copy  the  file  to  the  console. It  also  wraps  the  output  in
   # ===BEGIN===/===END=== markers.
   #

   namespace eval RETR {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::sock sock

      proc ::ftpd::command::RETR { sock fnam } {
         ::OS32::RETR::TopHalf $sock $fnam RETR
      }

      proc TopHalf { sock fnam ftpcmd } {
         CheckNotAllowed $sock $ftpcmd
         CheckOperatorBusy $sock
         set fnam [WildFile $sock [string toupper $fnam] $ftpcmd]
         upvar #0 ::ftpd::$sock data
         set data(fnam) $fnam
         BottomHalf $sock RETR "FTP COPYOUT,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable sock
               variable dimmeris
               upvar #0 ::ftpd::$sock data
            }
            "^\\*=== BEGIN COPYOUT .*? ===" {
               Dimmer on $0
               BeginData $sock 150 "Transmitting $data(fnam)"
               set data(nrec) 0
            }
            "^\\*FILE NOT FOUND" {
               set data(error) [list 550 "File not found, $data(fnam)"]
            }
            "^FILE STUCK - TRY ABORT\$" {
               Dimmer off $0
               if { ![info exists data(nrec)] } {
                  set data(nrec) 0
               }
               ReplyCommand $sock 451 "Whoops, file got stuck at $data(nrec) records"
               unset data(nrec)
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  ReplyCommand $sock 450 "Command line error, try again"
               } else {
                  set data(error) [list 550 $1]
               }
            }
            "^\\*.*\\.BG:(PERKIN-ELMER OS/32 COPY)" {
               # ignore
            }
            "^\\*.*\\.BG:END OF TASK" {
               # ignore
            }
            "^\\*.*\\.BG:(.*)" {
               SendData $sock "$1"
               incr data(nrec)
            }
            "=== END COPYOUT .*? ===" {
               Dimmer off $0
               if { ![info exists data(nrec)] } {
                  set data(nrec) 0
               }
               if { [info exists data(error)] } {
                  ReplyCommand $sock [lindex $data(error) 0] [lindex $data(error) 1]
                  unset data(error)
               } else {
                  EndData $sock 226 "$data(fnam) downloaded, $data(nrec) records"
               }
               unset data(nrec)
            }
         }
      }
   }

;######################################################################
   #
   # RNFR/RNTO -- Rename file
   #

   namespace eval RNFR {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::sock sock
      upvar #0 [namespace parent]::osline osline

      proc ::ftpd::command::RNFR { sock fnam } {
         ::OS32::RNFR::TopHalf $sock $fnam RNFR
      }

      proc TopHalf { sock fnam ftpcmd } {
         CheckReadOnly $sock $ftpcmd
         CheckNotAllowed $sock $ftpcmd
         upvar #0 ::ftpd::$sock data
         set fnam [WildFile $sock [string toupper $fnam] $ftpcmd]
         set data(fnam1) $fnam
         ReplyCommand $sock 350 "RNFR OK"
      }
   }

   namespace eval RNTO {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::sock sock
      upvar #0 [namespace parent]::osline osline

      proc ::ftpd::command::RNTO { sock fnam } {
         ::OS32::RNTO::TopHalf $sock $fnam RNTO
      }

      proc TopHalf { sock fnam ftpcmd } {
         CheckReadOnly $sock $ftpcmd
         CheckNotAllowed $sock $ftpcmd
         CheckOperatorBusy $sock
         upvar #0 ::ftpd::$sock data
         set fnam [WildFile $sock [string toupper $fnam] $ftpcmd]
         set data(fnam2) $fnam
         BottomHalf $sock $ftpcmd "FTP RENAME,$data(fnam1),$data(fnam2)"
      }

      proc LinePatternMatch { line } {

         awkward $line {
            BEGIN {
               variable ftpcmd
               variable sock
               variable dimmeris
               upvar #0 ::ftpd::$sock data
            }
            "^\\*=== BEGIN RENAME (.*) (.*) ===" {
               Dimmer on $0
            }
            "^\\*(ASGN-ERR  TYPE=NAME.*)" {
               set data(error) [list 550 "File not found, $data(fnam1)"]
            }
            "^\\*(RENM-ERR  TYPE=NAME.*)" {
               set data(error) [list 550 "Destination $data(fnam2) already exists, $data(fnam1) not renamed"]
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  ReplyCommand $sock 450 "Command line error, try again"
               } else {
                  set data(error) [list 550 $1]
               }
            }
            "^\\*(FILE RENAMED)" {
               # ignore
            }
            "^\\*=== END RENAME (.*) (.*) ===" {
               Dimmer off $0
               if { [info exists data(error)] } {
                  ReplyCommand $sock $data(error)
                  unset data(error)
               } else {
                  ReplyCommand $sock 250 "$data(fnam1) renamed $data(fnam2)"
               }
               unset data(fnam1)
               unset data(fnam2)
            }
         }
      }
   }


;######################################################################
   #
   # STOR -- Store file
   #
   # Invoke  EDIT/32  through  a  CSS that  allocates  and  renames  the
   # temporary  files,  and   cleans  up  after  itself.   This  one  is
   # complicated by  the fact that we  do not know the  record length in
   # the  top half,  and we  cannot receive  data while  in that  socket
   # event.
   #
   # This is where we introduce  a proc called PromptPatternMatch, which
   # checks for  prompts, before we  get the carriage return  that would
   # trigger LinePatternMatch.
   #

   namespace eval STOR {

      upvar #0 [namespace parent]::ftpcmd ftpcmd
      upvar #0 [namespace parent]::sock sock
      upvar #0 [namespace parent]::osline osline

      proc ::ftpd::command::STOR { sock fnam } {
         ::OS32::STOR::TopHalf $sock $fnam STOR
      }

      proc TopHalf { sock fnam ftpcmd } {
         CheckReadOnly $sock $ftpcmd
         CheckNotAllowed $sock $ftpcmd
         CheckOperatorBusy $sock
         upvar #0 ::ftpd::$sock data
         set fnam [WildFile $sock [string toupper $fnam] $ftpcmd]
         set data(fnam) $fnam
         # This command will fail with a USAGE error
         BottomHalf $sock $ftpcmd "FTP $ftpcmd,$fnam"
      }

      proc LinePatternMatch { line } {

         awkward $line {

            BEGIN {
               variable ftpcmd
               variable sock
               variable dimmeris
               upvar #0 ::ftpd::$sock data
            }
            # Now we can read all the data to work out record length
            "^\\*STOR (EXISTS|NEWFILE)" {
               # Check permission to *replace* the file
               if { $1 == "EXISTS" } {
                  if { [HaveACE $sock RO] && ![HaveACE $sock $ftpcmd+] } {
                     ReplyCommand $sock 550 "Permission denied (lack permission to replace existing file)"
                     return
                  }
               }
               Dimmer on $0
               BeginData $sock 150 "Transmitting $data(fnam)"
               set data(reclen) 80
               set data(nrec) 0
               set data(ccc) 0
               while {1} {
                  set ret -1
                  if { [catch {
                                 set ret [gets $data(sock2) line]
                              } msg] } {
                     BrokenSocket $sock
                     return
                  }
                  if { $ret <= 0 } break
                  set line [string trimright $line]
                  lappend data(storme) $line
                  set len [string length $line]
                  if { $len > $data(reclen) } { set data(reclen) $len }
                  incr data(nrec)
               }
               if { [expr $data(reclen)%4] > 0 } {
                  incr data(reclen) [expr 4-$data(reclen)%4]
               }
               # This command should work now
               send -- "FTP COPYIN,$data(fnam),$data(reclen)\r"
            }
            "^\\*=== BEGIN COPYIN .*? ===" {
            }
            "^FILE STUCK - TRY ABORT\$" {
               Dimmer off $0
               ReplyCommand $sock 451 "Whoops, file got stuck at record $data(ccc) of $data(nrec)"
            }
            "^\\*(DELE-ERR  TYPE=PROT)" {
               set data(error) [list 550 "Cannot upload file because it is write protected"]
            }
            "^\\*?(....-ERR.*)" {
               if { $dimmeris == "off" } {
                  ReplyCommand $sock 450 "Command line error, try again"
               } else {
                  set data(error) [list 550 $1]
               }
            }
            "^\\*=== END COPYIN .*? ===" {
               Dimmer off $0
               if { [info exists data(error)] } {
                  ReplyCommand $sock [lindex $data(error) 0] [lindex $data(error) 1]
                  unset data(error)
               } else {
                  EndData $sock 226 "$data(fnam) uploaded, $data(ccc) records, $data(reclen) chars reclen"
               }
               unset data(reclen)
               unset data(nrec)
               unset data(ccc)
            }
         }
      }

      proc PromptPatternMatch { line } {

         awkward $line {

            BEGIN {
               variable sock
               variable osline
               upvar #0 ::ftpd::$sock data
            }
            "^\\*.+\\.BG:.+\\.BG>" {
               if { $data(ccc) < $data(nrec) } {
                  set line [lindex $data(storme) $data(ccc)]
                  if { $line == "" } { set line " " }
                  send -- "$line\r"
                  incr data(ccc)
               } else {
                  unset data(storme)
                  send -- "\r"
               }
               set osline ""
            }
            "^\\*\\.BG>" {
               send -- "done\r"
               set osline ""
            }
         }
      }
   }

;######################################################################
   #
   # SYST -- Return system information
   #
   # No use  pretending that we are  UNIX or Windows. You  can configure
   # the ostype in ftpd.config.
   #

   namespace eval SYST {
      proc ::ftpd::command::SYST { sock list } {
         CheckNotAllowed $sock SYST
         upvar #0 ::ftpd::$sock data
         upvar #0 ::OS32::config::ostype ostype
         upvar #0 ::OS32::SYST::notfirsttime notfirsttime
         ReplyCommand $sock 215 "$ostype" [info exists data(notfirsttime)]
         set data(notfirsttime) 1
      }
   }

;######################################################################
   #
   # USER -- User connect
   #
   # Slightly misleading. We're checking the client IP address. We can't
   # check the username until we receive the PASS command.
   #

   namespace eval USER {

      # Using default ::ftpd::command::USER proc
      # Note: CheckNotAllowed not possible this early

      proc AuthIpCallback { ip } {
         upvar #0 ::OS32::config::allowip allowip
         if { $allowip != "all" } {
            foreach allow $allowip {
               if { $ip == $allow } {
                  # success/fail will get logged by PASS command
                  return 1
               }
            }
            # Outsiders!
            TrafficLight red "FTP CONNECTION ($ip) REJECTED"
            return 0
         } else {
            # free for all!
            TrafficLight green "FTP CONNECTION ($ip) ACCEPTED"
            return 1
         }
      }
   }

;######################################################################
   #
   # Bottom half and convenience routines.
   #

   proc WildFile { sock fnam cmd } {

      set fnam [string toupper $fnam]

      if { $cmd == "LIST" || $cmd == "NLST" } {
         set re {^([-*A-Z][-*A-Z0-9]*)(\.[-*A-Z0-9]*)?$}
         set fnam [string map { * - ? * } $fnam]
         set acceptnull 1
         set err [list 501 "Invalid filename or wildcard pattern"]
      } else {
         if { $cmd == "STOR" || $cmd == "APPE" } {
            regexp {([^/]+)$} $fnam -> fnam
         }
         set re {^([A-Z][A-Z0-9]*)(\.[A-Z0-9]*)?$}
         set acceptnull 0
         set err [list 501 "Invalid filename $fnam, must be letters, digits, 8.3 max"]
      }

      if { $fnam == "" } {
         if { $acceptnull == 0 } {
            ReplyCommand $sock 501 "Missing filename"
            return -level 2
         }
      } elseif { ![regexp $re $fnam -> nam ext] } {
         ReplyCommand $sock [lindex $err 0] [lindex $err 1]
         return -level 2                  ;# extension inc dot -----v
      } elseif { [string length $nam] > 8 || [string length $ext] > 4 } {
         ReplyCommand $sock 501 "Invalid filename $fnam, 8.3 max"
         return -level 2
      }

      upvar #0 ::ftpd::$sock data
      return $data(vol)$fnam/$data(cwd)
   }

   proc CdBlacklist { acct } {
      upvar #0 ::OS32::config::cdblacklist cdblacklist
      if { [lsearch $cdblacklist $acct] >= 0 } {
         return 1
      } else {
         return 0
      }
   }

   proc InitialAccount { sock } {
      upvar #0 ::ftpd::$sock data
      set i [lsearch -regexp $data(acl) {[0-9]+}]
      if { $i >= 0 } {
         return [lindex $data(acl) $i]
      } else {
         return -1
      }
   }

   proc CheckOperatorBusy {sock} {
      variable taskcount
      if { $taskcount > 0 } {
         ReplyCommand $sock 450 "Operator busy, do not disturb"
         return -level 2
      }
   }

   # Note: must be called BEFORE CheckNotAllowed
   proc CheckReadOnly { sock ftpcmd { plus "" } } {
      if { [HaveACE $sock RO] && ![HaveACE $sock +$ftpcmd] && ![HaveACE $sock $ftpcmd+] } {
         ReplyCommand $sock 550 "Permission denied (user is read only)"
         return -level 2
      }
   }

   # Note: must be called AFTER CheckReadOnly
   proc CheckNotAllowed { sock ftpcmd } {
      if { [HaveACE $sock -$ftpcmd] } {
         ReplyCommand $sock 550 "Permission denied ($ftpcmd not allowed)"
         return -level 2
      }
   }

   proc HaveACE { sock check } {
      upvar #0 ::ftpd::$sock data
      if { [lsearch -exact $data(acl) $check] >= 0 } {
         return 1
      } else {
         return 0
      }
   }

   proc ShowACL { sock } {
      upvar #0 ::ftpd::$sock data
      return "([join $data(acl) ,])"
   }

   proc BottomHalf { sock ftpcmd oscmd } {
      if { $::OS32::ftpcmd != "" } {
         ReplyCommand $sock 450 "FTP command in progress, try again" fip
         return
      }
      set ::OS32::ftpcmd $ftpcmd
      set ::OS32::sock $sock
      send -- "$oscmd\r"
   }

   proc BeginData { sock err ftpcmd } {
      if { $err != 150 } {
         puts "\n\n*** BeginData must always be called with 150 ***\n\n"
         expr {"abcxyz"+1}
      }
      if { [catch {
                     puts $sock "$err $ftpcmd"
                     ::ftpd::PasvCheckAndWait $sock
                  } msg] } {
         BrokenSocket $sock
         return -code return
      }
   }

   proc SendData { sock line } {
      upvar #0 ::ftpd::$sock data
      if { [catch {
                     puts -nonewline $data(sock2) "$line\r\n"
                  } msg] } {
         BrokenSocket $sock
         return -code return
      }
   }

   proc EndData { sock err ftpcmd } {
      if { $err != 226 } {
         puts "\n\n*** BeginData must always be called with 226 ***\n\n"
         expr {"abcxyz"+1}
      }
      ReplyCommand $sock $err "$ftpcmd"
   }

   proc ReplyCommand { sock err mess { opt "" } } {

      #
      # opt values:
      #
      # - 0    do not include VT100 sequences (SYST first only)
      # - 1    DO include VT100 sequences (SYST subsequent calls)
      # - fip  FTP command in progress, do not clobber ftpcmd
      #

      ::ftpd::FinishData $sock

      variable vt100
      if { $opt != "0" && ![HaveACE $sock -vt] } {
         set vt $vt100(normal)
         set vt0 $vt100(normal)
         for {set n 3} {$n >= 1} {incr n -1} {
            set elem "[string range $err 0 [expr {$n-1}]][string repeat x [expr {3-$n}]]"
            if { [info exists vt100($elem)] } {
               set vt [set vt100($elem)]
               break
            }
         }
      } else {
         set vt ""
         set vt0 ""
      }

      if { [catch {
                     puts $sock "$err $vt$mess$vt0"
                  } msg] } {
         BrokenSocket $sock
         return -status return 0
      }

      if { $opt != "fip" } {
         set ::OS32::ftpcmd ""
         set ::OS32::sock ""
      }

      return 1
   }

   proc BrokenSocket { sock } {
      set ::OS32::ftpcmd ""
      set ::OS32::sock ""
      upvar #0 ::ftpd::$sock data
      variable vt100
      puts stderr "\n$vt100(red)*** BROKEN SOCK ***$vt100(normal)\n"
      Dimmer off ""
      catch { close $data(sock2) }
      catch { close $sock }
      catch { unset data }
   }

   proc unesc { str } {
      regsub -all "\x1b" $str <ESC> str
      return $str
   }

   proc squish { str } {
      regsub -all "\r?\n" $str { } str
      regsub -all { +}    $str { } str
      return [string trim $str]
   }

   proc LogNothing { severity wot } {
      if { $severity == "ERROR" } {
         TrafficLight red $wot
      }
   }

   variable dimmeris off
   upvar #0 ::OS32::config::vt100 vt100

   proc Dimmer { onoff { str "" } } {
      variable vt100
      switch $onoff {
         "on" {
            puts -nonewline "\r$vt100(on)$str"
            variable dimmeris on
         }
         "off" {
            puts -nonewline "\r$str$vt100(off)"
            variable dimmeris off
         }
      }
   }

   proc TrafficLight { colour message } {
      variable dimmeris
      variable vt100
      set cn [set vt100($colour)]
      set dm [set vt100($dimmeris)]
      puts -nonewline "\r*$cn$message$dm\n*"
   }

   proc DumpConfig {} {
      puts =================================================================
      foreach var [lsort [info vars config::*]] {
         if { [array exists $var] } {
            set arr $var
            foreach elem [lsort [array names $var]] {
               set val [squish [set $arr\($elem)]]
               puts "$arr\($elem) = [unesc $val]"
            }
         } else {
            set val [squish [set $var]]
            puts "$var = [unesc $val]"
         }
      }
      puts =================================================================
   }

;######################################################################
   #
   # Our awk-like pattern matching construct
   #

   proc awkward { 0 arglist } {
      set awk {}
      foreach line [split $arglist \n] {
         set line [string trim $line]
         if { $line == "" || [string range $line 0 0] == "#" } continue
         if { $awk != "" } { append awk \n }
         append awk $line
      }
      set match 0
      foreach { re action } $awk {
         if { $re == "BEGIN" || $re == "END" } {
            eval $action
            continue
         }
         if { !$match && [regexp $re $0 -> 1 2 3 4 5 6 7 8 9] } {
            eval $action
            set match 1
            continue
         }
      }
      return $match
   }

;######################################################################
   #
   # FTP start, stop, users
   #

   proc CheckWeHaveFTP {} {
      if { ![info exists config::host] ||
           ![info exists config::port] ||
           $config::port <= 0 } {
         puts -nonewline "\nFTP server is disabled"
         return -level 2
      }
   }

   proc FileIs600 { fnam } {
      file stat $fnam stat
      set perm [expr {$stat(mode)%512}]
      if { $perm == 0600 || $perm ==  0400 } {
         return 1
      } else {
         return 0
      }
   }

   proc StartFTP {} {

      upvar #0 ::ftpd::serviceSock serviceSock

      if { [info exists serviceSock] } {
         puts -nonewline "\nFTP server already running"
         return
      }

      puts ""

      namespace eval ::OS32 {
         if { [file exists ftpd.config] } {
            if { [FileIs600 ftpd.config] } {
               puts "$vt100(green)Sourcing ftpd.config$vt100(normal)"
               source ftpd.config
            } else {
               puts "$vt100(red)Ignoring ftpd.config, must be chmod 600 or 400$vt100(normal)"
            }
         } else {
            puts "$vt100(green)No ftpd.config$vt100(normal)"
         }
         if {$config::debugconfig} {
            DumpConfig
         }
      }

      CheckWeHaveFTP

      set ::ftpd::welcome $config::welcome
      set ::ftpd::contact $config::contact
      set ::ftpd::port    $config::port

      ftpd::config -authIpCmd ::OS32::USER::AuthIpCallback
      ftpd::config -logCmd    ::OS32::LogNothing

      ftpd::server $config::host

      variable vt100
      puts -nonewline "$vt100(green)$config::welcome on $config::host port $config::port$vt100(normal)"
   }

   proc StopFTP {} {

      CheckWeHaveFTP

      upvar #0 ::ftpd::serviceSock serviceSock

      if { ![info exists serviceSock] } {
         puts -nonewline "\nFTP server not running"
         return
      }

      Dimmer off

      puts -nonewline "\nClosing listening socket"
      catch { close $serviceSock }
      unset serviceSock

      set socks [info vars ::ftpd::sock*]

      if { [llength $socks] > 0 } {
         foreach sock $socks {
            upvar #0 $sock data
            if { $data(sock2) != {} } {
               puts -nonewline "\nClosing $data(user)@$data(ip) passive socket"
               catch { close $data(sock2) }
            }
            regsub ::ftpd:: $sock {} sock
            puts -nonewline "\nClosing $data(user)@$data(ip) command socket"
            catch { close $sock }
            array unset data
         }
      }

      set ::OS32::ftpcmd ""
   }

   proc ShowFTP {} {

      CheckWeHaveFTP

      upvar #0 ::ftpd::serviceSock serviceSock

      if { ![info exists serviceSock] } {
         puts -nonewline "\nFTP server not running"
         return
      }

      set n 0
      puts ""
      foreach sock [info vars ::ftpd::sock*] {
         upvar $sock data
         puts "$data(user)@$data(ip)"
         incr n
      }
      puts -nonewline "$n CONNECTED"
   }

;######################################################################
   #
   # The interact/expect loop
   #

   variable osline ""
   variable taskcount 0

   proc DoExpect {} {
      namespace eval :: {
         interact {
            -o
            # We'll usually trigger pattern matching on <CR>.
            -re "\r" {
               upvar #0 ::OS32::osline osline
               if { [string match "TSKID = *" $osline] } {
                  incr ::OS32::taskcount
               } elseif { [string match "*:END OF TASK*" $osline] } {
                  incr ::OS32::taskcount -1
               } elseif { $osline == "*START FTP SERVER" } {
                  ::OS32::StartFTP
               } elseif { $osline == "*STOP FTP SERVER" } {
                  ::OS32::StopFTP
               } elseif { $osline == "*SHOW FTP USERS" } {
                  ::OS32::ShowFTP
               }
               upvar #0 ::OS32::ftpcmd ftpcmd
               if { $ftpcmd != "" } {
                  set LinePatternMatch ::OS32::[set ftpcmd]::LinePatternMatch
                  if { [info procs $LinePatternMatch] != "" } {
                     $LinePatternMatch $osline
                  }
               }
               puts ""
               set osline ""
            }
            # Discard <NL> and annoying <DEL> characters.
            -re "(\n|\x7f)" {
            }
            # All  other  characters  are echoed  and  assembled  into
            # lines. But  some OS/32  programs have their  own prompts
            # that have to spot before we ever get a carriage return.
            -re . {
               upvar #0 ::OS32::ftpcmd ftpcmd
               upvar #0 ::OS32::osline osline
               set c $interact_out(0,string)
               if { $c != 0x7f } {
                  append osline $c
                  puts -nonewline stderr $c
               }
               if { $ftpcmd != "" } {
                  set PromptPatternMatch ::OS32::[set ftpcmd]::PromptPatternMatch
                  if { [info procs $PromptPatternMatch] != "" } {
                     $PromptPatternMatch $osline
                  }
               }
            }
            timeout $::OS32::config::timeout {
               if { $ftpcmd != "" } {
                  TrafficLight red "*** TIMEOUT ***"
                  send "\$WRITE FILE STUCK - TRY ABORT\r"
               }
            }
         }
      }
   }
}

;######################################################################
   #
   # Main program
   #

namespace import OS32::*

namespace eval OS32 {

   Dimmer off

   StartFTP

   set fd [ open $::OS32::config::inifile r ]
   set schluck [ read $fd ]
   if { [regexp -nocase {\s*att[^ ]* +pas +([0-9]+)} $schluck -> mtmport] } {
      puts "\n$vt100(green)PAS device for MTM authentication on port $mtmport$vt100(normal)"
   } else {
      set mtmport -1
      puts "\n$vt100(red)Cannot find PAS attach command -> no MTM authentication$vt100(normal)"
   }
   close $fd

   namespace eval :: {
      puts ""
      catch { exec killall -9 id32 }
      spawn ./id32 $::OS32::config::inifile
   }

   unset fd
   unset schluck

   DoExpect

   Dimmer off
}
